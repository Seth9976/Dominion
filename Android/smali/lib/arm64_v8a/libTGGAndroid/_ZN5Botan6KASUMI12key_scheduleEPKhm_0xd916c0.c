// 函数: _ZN5Botan6KASUMI12key_scheduleEPKhm
// 地址: 0xd916c0
// 来自: E:\torrent\Cursor\Dominion_1.0.3315\split_config.arm64_v8a\lib\arm64-v8a\libTGGAndroid.so

uint16_t* x0 = Botan::allocate_memory(0x10, 2)
uint32_t x8_2 = _byteswap(zx.d(*arg2)) u>> 0x10
*x0 = x8_2.w
x0[8] = x8_2.w ^ 0x123
uint16_t x9_3 = (_byteswap(zx.d(*(arg2 + 2))) u>> 0x10).w
x0[1] = x9_3
x0[9] = x9_3 ^ 0x4567
uint16_t x9_7 = (_byteswap(zx.d(*(arg2 + 4))) u>> 0x10).w
x0[2] = x9_7
x0[0xa] = x9_7 ^ 0x89ab
uint16_t x9_11 = (_byteswap(zx.d(*(arg2 + 6))) u>> 0x10).w
x0[3] = x9_11
x0[0xb] = x9_11 ^ 0xcdef
uint16_t x9_15 = (_byteswap(zx.d(*(arg2 + 8))) u>> 0x10).w
x0[4] = x9_15
x0[0xc] = x9_15 ^ 0xfedc
uint16_t x9_19 = (_byteswap(zx.d(*(arg2 + 0xa))) u>> 0x10).w
x0[5] = x9_19
x0[0xd] = x9_19 ^ 0xba98
uint16_t x9_23 = (_byteswap(zx.d(*(arg2 + 0xc))) u>> 0x10).w
x0[6] = x9_23
x0[0xe] = x9_23 ^ 0x7654
uint16_t x9_27 = (_byteswap(zx.d(*(arg2 + 0xe))) u>> 0x10).w
x0[7] = x9_27
x0[0xf] = x9_27 ^ 0x3210
int16_t* x9_29 = *(arg1 + 8)
void* x10_1 = *(arg1 + 0x10) - x9_29

if (x10_1 s>> 1 u<= 0x3f)
    std::__ndk1::vector<uint16_t, Botan::secure_allocator<uint16_t> >::__append(&arg1[8])
    x8_2 = zx.d(*x0)
    x9_29 = *(arg1 + 8)
else if (x10_1 != 0x80)
    *(arg1 + 0x10) = &x9_29[0x40]

*x9_29 = (3 & (x8_2 u>> 0xe).w) | ((0xffff & x8_2) << 2).w
uint32_t x8_3 = zx.d(x0[0xa])
*(*(arg1 + 8) + 2) = (1 & (x8_3 u>> 0xf).w) | ((0xffff & x8_3) << 1).w
uint32_t x8_4 = zx.d(x0[1])
*(*(arg1 + 8) + 4) = (0x1f & (x8_4 u>> 0xb).w) | ((0xffff & x8_4) << 5).w
*(*(arg1 + 8) + 6) = x0[0xc]
*(*(arg1 + 8) + 8) = (_byteswap(zx.d(x0[5])) u>> 0x10).w
*(*(arg1 + 8) + 0xa) = x0[0xb]
uint32_t x8_10 = zx.d(x0[6])
*(*(arg1 + 8) + 0xc) = (0x1fff & (x8_10 u>> 3).w) | ((0xffff & x8_10) << 0xd).w
*(*(arg1 + 8) + 0xe) = x0[0xf]
uint32_t x8_12 = zx.d(x0[1])
*(*(arg1 + 8) + 0x10) = (3 & (x8_12 u>> 0xe).w) | ((0xffff & x8_12) << 2).w
uint32_t x8_13 = zx.d(x0[0xb])
*(*(arg1 + 8) + 0x12) = (1 & (x8_13 u>> 0xf).w) | ((0xffff & x8_13) << 1).w
uint32_t x8_14 = zx.d(x0[2])
*(*(arg1 + 8) + 0x14) = (0x1f & (x8_14 u>> 0xb).w) | ((0xffff & x8_14) << 5).w
*(*(arg1 + 8) + 0x16) = x0[0xd]
*(*(arg1 + 8) + 0x18) = (_byteswap(zx.d(x0[6])) u>> 0x10).w
*(*(arg1 + 8) + 0x1a) = x0[0xc]
uint32_t x8_20 = zx.d(x0[7])
*(*(arg1 + 8) + 0x1c) = (0x1fff & (x8_20 u>> 3).w) | ((0xffff & x8_20) << 0xd).w
*(*(arg1 + 8) + 0x1e) = x0[8]
uint32_t x8_22 = zx.d(x0[2])
*(*(arg1 + 8) + 0x20) = (3 & (x8_22 u>> 0xe).w) | ((0xffff & x8_22) << 2).w
uint32_t x8_23 = zx.d(x0[0xc])
*(*(arg1 + 8) + 0x22) = (1 & (x8_23 u>> 0xf).w) | ((0xffff & x8_23) << 1).w
uint32_t x8_24 = zx.d(x0[3])
*(*(arg1 + 8) + 0x24) = (0x1f & (x8_24 u>> 0xb).w) | ((0xffff & x8_24) << 5).w
*(*(arg1 + 8) + 0x26) = x0[0xe]
*(*(arg1 + 8) + 0x28) = (_byteswap(zx.d(x0[7])) u>> 0x10).w
*(*(arg1 + 8) + 0x2a) = x0[0xd]
uint32_t x8_30 = zx.d(*x0)
*(*(arg1 + 8) + 0x2c) = (0x1fff & (x8_30 u>> 3).w) | ((0xffff & x8_30) << 0xd).w
*(*(arg1 + 8) + 0x2e) = x0[9]
uint32_t x8_32 = zx.d(x0[3])
*(*(arg1 + 8) + 0x30) = (3 & (x8_32 u>> 0xe).w) | ((0xffff & x8_32) << 2).w
uint32_t x8_33 = zx.d(x0[0xd])
*(*(arg1 + 8) + 0x32) = (1 & (x8_33 u>> 0xf).w) | ((0xffff & x8_33) << 1).w
uint32_t x8_34 = zx.d(x0[4])
*(*(arg1 + 8) + 0x34) = (0x1f & (x8_34 u>> 0xb).w) | ((0xffff & x8_34) << 5).w
*(*(arg1 + 8) + 0x36) = x0[0xf]
*(*(arg1 + 8) + 0x38) = (_byteswap(zx.d(*x0)) u>> 0x10).w
*(*(arg1 + 8) + 0x3a) = x0[0xe]
uint32_t x8_40 = zx.d(x0[1])
*(*(arg1 + 8) + 0x3c) = (0x1fff & (x8_40 u>> 3).w) | ((0xffff & x8_40) << 0xd).w
*(*(arg1 + 8) + 0x3e) = x0[0xa]
uint32_t x8_42 = zx.d(x0[4])
*(*(arg1 + 8) + 0x40) = (3 & (x8_42 u>> 0xe).w) | ((0xffff & x8_42) << 2).w
uint32_t x8_43 = zx.d(x0[0xe])
*(*(arg1 + 8) + 0x42) = (1 & (x8_43 u>> 0xf).w) | ((0xffff & x8_43) << 1).w
uint32_t x8_44 = zx.d(x0[5])
*(*(arg1 + 8) + 0x44) = (0x1f & (x8_44 u>> 0xb).w) | ((0xffff & x8_44) << 5).w
*(*(arg1 + 8) + 0x46) = x0[8]
*(*(arg1 + 8) + 0x48) = (_byteswap(zx.d(x0[1])) u>> 0x10).w
*(*(arg1 + 8) + 0x4a) = x0[0xf]
uint32_t x8_50 = zx.d(x0[2])
*(*(arg1 + 8) + 0x4c) = (0x1fff & (x8_50 u>> 3).w) | ((0xffff & x8_50) << 0xd).w
*(*(arg1 + 8) + 0x4e) = x0[0xb]
uint32_t x8_52 = zx.d(x0[5])
*(*(arg1 + 8) + 0x50) = (3 & (x8_52 u>> 0xe).w) | ((0xffff & x8_52) << 2).w
uint32_t x8_53 = zx.d(x0[0xf])
*(*(arg1 + 8) + 0x52) = (1 & (x8_53 u>> 0xf).w) | ((0xffff & x8_53) << 1).w
uint32_t x8_54 = zx.d(x0[6])
*(*(arg1 + 8) + 0x54) = (0x1f & (x8_54 u>> 0xb).w) | ((0xffff & x8_54) << 5).w
*(*(arg1 + 8) + 0x56) = x0[9]
*(*(arg1 + 8) + 0x58) = (_byteswap(zx.d(x0[2])) u>> 0x10).w
*(*(arg1 + 8) + 0x5a) = x0[8]
uint32_t x8_60 = zx.d(x0[3])
*(*(arg1 + 8) + 0x5c) = (0x1fff & (x8_60 u>> 3).w) | ((0xffff & x8_60) << 0xd).w
*(*(arg1 + 8) + 0x5e) = x0[0xc]
uint32_t x8_62 = zx.d(x0[6])
*(*(arg1 + 8) + 0x60) = (3 & (x8_62 u>> 0xe).w) | ((0xffff & x8_62) << 2).w
uint32_t x8_63 = zx.d(x0[8])
*(*(arg1 + 8) + 0x62) = (1 & (x8_63 u>> 0xf).w) | ((0xffff & x8_63) << 1).w
uint32_t x8_64 = zx.d(x0[7])
*(*(arg1 + 8) + 0x64) = (0x1f & (x8_64 u>> 0xb).w) | ((0xffff & x8_64) << 5).w
*(*(arg1 + 8) + 0x66) = x0[0xa]
*(*(arg1 + 8) + 0x68) = (_byteswap(zx.d(x0[3])) u>> 0x10).w
*(*(arg1 + 8) + 0x6a) = x0[9]
uint32_t x8_70 = zx.d(x0[4])
*(*(arg1 + 8) + 0x6c) = (0x1fff & (x8_70 u>> 3).w) | ((0xffff & x8_70) << 0xd).w
*(*(arg1 + 8) + 0x6e) = x0[0xd]
uint32_t x8_72 = zx.d(x0[7])
*(*(arg1 + 8) + 0x70) = (3 & (x8_72 u>> 0xe).w) | ((0xffff & x8_72) << 2).w
uint32_t x8_73 = zx.d(x0[9])
*(*(arg1 + 8) + 0x72) = (1 & (x8_73 u>> 0xf).w) | ((0xffff & x8_73) << 1).w
uint32_t x8_74 = zx.d(*x0)
*(*(arg1 + 8) + 0x74) = (0x1f & (x8_74 u>> 0xb).w) | ((0xffff & x8_74) << 5).w
*(*(arg1 + 8) + 0x76) = x0[0xb]
*(*(arg1 + 8) + 0x78) = (_byteswap(zx.d(x0[4])) u>> 0x10).w
*(*(arg1 + 8) + 0x7a) = x0[0xa]
uint32_t x8_80 = zx.d(x0[5])
*(*(arg1 + 8) + 0x7c) = (0x1fff & (x8_80 u>> 3).w) | ((0xffff & x8_80) << 0xd).w
*(*(arg1 + 8) + 0x7e) = x0[0xe]
return Botan::deallocate_memory(x0, 0x10, 2)
